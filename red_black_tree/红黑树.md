
## 红黑树的基本特性

(1) 每个节点或者是黑色，或者是红色。  
(2) 根节点是黑色。  
(3) 每个叶子节点是黑色。
(4) 如果一个节点是红色的，则它的子节点必须是黑色的。  
(5) 从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。

> 注意  
> 1. 特性(3)中的叶子节点，是只为空(NIL或null)的节点。
> 2. 特性(5)，确保没有一条路径会比其他路径长出俩倍。因而，红黑树是相对是接近平衡的二叉树。


> **红黑树插入删除演示网站：[Red/Black Tree Visualization (usfca.edu)](https://www.cs.usfca.edu/~galles/visualization/RedBlack.html)**

## 红黑树和AVL树的效率对比

> AVL是平衡二叉树

1.  如果插入一个节点引起了树的不平衡，AVL和RB-Tree都是最多只需要2次旋转操作，即两者旋转操作都是O(1)，总体插入操作为O(lgn)；但是在删除节点引起树的不平衡时，最坏情况下，AVL需要维护从被删节点到root这条路径上所有节点的平衡性，因此需要旋转的量级O(logN)，而RB-Tree最多只需3次旋转，只需要O(1)的复杂度。

2.  其次，AVL的结构相较RB-Tree来说更为平衡，在插入和删除节点更容易引起Tree的unbalance，因此在大量数据需要插入或者删除时，AVL需要rebalance的频率会更高。因此，RB-Tree在需要大量插入和删除节点的场景下，效率更高。自然，由于AVL高度平衡，因此AVL的查找效率更高。

## 红黑树的插入、删除

### 插入

- 插入节点为红黑树中第一个节点时，将节点颜色设置为黑色，并直接插入作为root节点
- 插入节点不为红黑树第一个节点时，将节点颜色设置为红色。根据二叉搜索树的插入规则找到插入位置插入，并可能需要进行调整
> 节点设置为红色原因：因为插入位置都是在叶子节点位置，红色节点不会破坏黑高，保证黑高不变

#### 控制平衡

- 插入位置的父节点为黑色

由于插入节点颜色为红色，并不会破坏红黑树规则，故不需要进行调整

> 下面举例以父节点为左节点举例，父节点为右节点时操作与其是左节点时的操作是对称的

- 插入位置的父节点为红色，叔叔节点（父节点的兄弟节点）为红色

将父节点和叔叔节点设为黑色，将祖父节点设为红色。然后将祖父节点作为新节点继续向上平衡。如果祖父节点是根节点，那么需要再将其置为黑色

- 插入位置的父节点为红色，叔叔节点为黑色，新插入节点在父节点左侧

对祖父节点进行右旋操作，并将祖父节点置为红色，父节点置为黑色

- 插入位置的父节点为红色，叔叔节点为黑色，新插入节点在父节点左侧

进行双旋，对父节点进行左单旋，对祖父节点进行右单旋。将子节点置为黑色，将祖父节点置为红色。

- 最后置黑：调整完成后，检查根节点是否为黑色，若不是，则要将根节点变为黑色。对根节点置黑并不违反三条规定。

### 删除

红黑树的删除操作和二叉搜索树的删除操作差不多，只是在删除完节点之后，需要进行旋转以达到平衡。

当删除的节点是红色时，不会破坏红黑树的特性，因为黑高不会变，故不需要进行调整。

当删除的节点是黑色时，需要进行调整

#### 控制平衡

> 下面举例以x为左节点举例，x为右节点时操作与其是左节点时的操作是对称的

1.  x的兄弟节点w是红色

当w为红色时，w必须有黑色孩子，可以改变w和x.parent的颜色，再对x.parent进行一次左旋，红黑树性质得以保持。现在x的新兄弟是旋转之前w的某个孩子，其颜色为黑，故我们将情况1转换成了情况2、3、4

2. x的兄弟节点w为黑色，且w的两个孩子都是黑色

因为w是黑色，故从x和w上去掉一冲黑色，从而x只有一重黑色，而w为红色。为了补偿从x和w中去掉的一重黑色，可以通过原来是红色或黑色的x.parent内新增一重额外黑色。通过x.parent为新节点x来重复循环。注意如果通过情况1进入情况2，则新节点x是红黑色的，因为原来的x.parent是红色的。故新节点x的颜色为red，且在循环结束后，新节点x会被着色为黑色

3. x的兄弟节点w是黑色的，w的左孩子是红色，右孩子是黑色

交换w和w左孩子的颜色，并对w进行右旋。现在x的新兄弟w是一个有红色右孩子的黑节点，这样情况3变为情况4

4. x的兄弟w是黑色的，且w的右孩子是红色的

通过做某些颜色修改并对x.parent做一次左旋，可以去掉x的额外黑色来把它变成单独黑色。将x置为根后，while循环结束。


